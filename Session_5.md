Here is the complete documentation ready for your GitHub repository. It synthesizes everything we discussedâ€”from the theoretical math of Shannon to the bit-flipping dangers of real-world banking attacks.

You can copy and paste the block below directly into a `README.md` or a `.md` file in your repo.

-----

# Stream Ciphers & Secure PRGs: From Theory to Practice

## 1\. Introduction: The Need for Speed

Imagine you are watching a 4K movie on Netflix. The file size is massive. If Netflix had to wait to encrypt the *entire* movie file before sending it to you, you would be waiting hours for the stream to start.

Instead, they need a way to encrypt data **byte-by-byte** as it flows through the wire.

This is where **Stream Ciphers** come in. Unlike Block Ciphers (which encrypt chunks of data), Stream Ciphers act like a high-speed tape, masking data the instant it is created. They are the backbone of real-time communication, mobile encryption, and low-latency networks.

-----

## 2\. The Theoretical Foundation

### The "Holy Grail": The One-Time Pad (OTP)

To understand modern stream ciphers, we first look at the only mathematically unbreakable system: **The One-Time Pad**.

  * **The Concept:** You have a random key that is exactly as long as your message.
  * **The Math:** $C = M \oplus K$ (Ciphertext = Message XOR Key).
  * **Shannon's Perfect Secrecy:** In 1949, Claude Shannon proved that if the key is (1) truly random, (2) as long as the message, and (3) never reused, the ciphertext reveals **zero information**.

Even with infinite computing power, an attacker cannot crack it because the ciphertext could technically decrypt to *any* message of the same length.

-----

## 3\. The Practical Solution: PRGs and Stream Ciphers

In the real world, we cannot carry around 1GB keys to send 1GB videos. We cheat using a **Secure PRG**.

### A. Secure PRG (Pseudo-Random Generator)

  * **Analogy:** The "Engine."
  * **Function:** It takes a short, fixed-length secret (the **Key**) and "stretches" it into a long stream of random-looking bits (the **Keystream**).
  * **The Constraint:** It is not *truly* random (it's deterministic), but it must be **Cryptographically Secure**. This means passing the "Next-Bit Test": knowing the first $k$ bits shouldn't help you predict bit $k+1$.

### B. The Stream Cipher

  * **Analogy:** The "Loom."
  * **Function:** It takes the **Keystream** generated by the PRG and combines it with the **Plaintext** message.
  * **The Formula:**
    $$C_i = M_i \oplus S_i$$
    *(Ciphertext bit = Message bit XOR Keystream bit)*

### C. The Key Hierarchy

We don't XOR the secret key directly. The hierarchy is:

1.  **Secret Key ($k$):** The seed (DNA).
2.  **PRG Algorithm:** The factory.
3.  **Keystream ($S$):** The output material.
4.  **XOR:** The tool that applies the material to the message.

-----

## 4\. Security Definitions: "Good Enough" vs. "Perfect"

Since we are using short keys (PRGs) and not infinite keys (OTP), we cannot achieve Shannon's Perfect Secrecy. We settle for **Semantic Security**.

### Semantic Security

  * **The Definition:** An attacker should not be able to derive *any* information about the plaintext from the ciphertext (other than its length).
  * **The Test (IND-CPA):**
    1.  The Attacker gives the Challenger two messages: "Attack" and "Retreat".
    2.  The Challenger encrypts one of them randomly.
    3.  The Attacker sees the ciphertext.
    4.  If the Attacker cannot guess which message was encrypted with better than 50% accuracy (a coin toss), the system is Semantically Secure.

**Key Difference:**

  * **Perfect Secrecy:** Unbreakable by **God** (Infinite resources).
  * **Semantic Security:** Unbreakable by **Computers** (Polynomial time).

-----

## 5\. Critical Vulnerabilities (The "Gotchas")

Stream ciphers are fast, but they are fragile.

### A. Confidentiality vs. Integrity

  * **Confidentiality:** "You can't read my message." (Stream Ciphers do this well).
  * **Integrity:** "You can't change my message." (Stream Ciphers **FAIL** here).

**The Attack:**
Because the encryption is just `XOR`, it is **malleable**.
If an attacker flips bit \#5 in the Ciphertext, bit \#5 in the decrypted Plaintext also flips.

  * *Scenario:* Message says "Pay $1**0**0".
  * *Attack:* Attacker flips one bit.
  * *Result:* Message becomes "Pay $9**0**0".
  * *Fix:* You must use a **MAC (Message Authentication Code)** to detect tampering.

### B. The "Two-Time Pad" (Key Reuse)

This is the cardinal sin of stream ciphers. If you encrypt two different messages with the same **Key + Nonce**, you generate the same Keystream ($S$).

$$C_1 = M_1 \oplus S$$
$$C_2 = M_2 \oplus S$$

If the attacker captures both, they can XOR them together:
$$C_1 \oplus C_2 = (M_1 \oplus S) \oplus (M_2 \oplus S) = M_1 \oplus M_2$$

The key disappears\! The attacker now has the combination of your two plaintexts.

-----

## 6\. Implementation Example (Python)

This script demonstrates how a Stream Cipher works and proves the "Two-Time Pad" vulnerability.

```python
import os

def simple_xor(data, key_stream):
    """
    Simulates a stream cipher by XORing data with a keystream.
    """
    return bytes([b ^ k for b, k in zip(data, key_stream)])

def get_keystream(length, seed):
    """
    A DUMMY PRG (Do not use in production).
    In real life, this would be ChaCha20 or AES-CTR.
    Here, we use Python's random seeded by a 'secret key'.
    """
    import random
    random.seed(seed) # The 'Key' sets the state
    return random.randbytes(length)

# --- SCENARIO 1: Proper Usage ---
secret_key = "MySuperSecretKey"
message = b"Attack at Dawn!!"

# 1. Generate Keystream
keystream = get_keystream(len(message), secret_key)

# 2. Encrypt
ciphertext = simple_xor(message, keystream)
print(f"Encrypted: {ciphertext.hex()}")

# 3. Decrypt
decrypted = simple_xor(ciphertext, keystream)
print(f"Decrypted: {decrypted.decode()}")


# --- SCENARIO 2: The Two-Time Pad Attack (Key Reuse) ---
print("\n--- ATTACK DEMO ---")

msg1 = b"Hello World"
msg2 = b"Hello Kevin"

# DANGER: Using the SAME key for both messages
ks = get_keystream(len(msg1), "WrongUsageKey")

c1 = simple_xor(msg1, ks)
c2 = simple_xor(msg2, ks)

# The Attacker intercepts c1 and c2. They don't have the key.
# But look what happens when they XOR the ciphertexts:
xor_of_ciphertexts = simple_xor(c1, c2)
xor_of_plaintexts  = simple_xor(msg1, msg2)

print(f"XOR of Ciphertexts: {xor_of_ciphertexts.hex()}")
print(f"XOR of Plaintexts:  {xor_of_plaintexts.hex()}")

if xor_of_ciphertexts == xor_of_plaintexts:
    print("\n[!] VULNERABILITY CONFIRMED:")
    print("The XOR of the ciphertexts is equal to the XOR of the plaintexts.")
    print("The attacker has stripped away the encryption key entirely.")
```

### Summary of Concepts

| Concept | Description |
| :--- | :--- |
| **MSB / LSB** | Most/Least Significant Bit. In crypto, predicting even the LSB (odd/even) counts as breaking the cipher. |
| **Distribution** | Ideally, ciphertext should look Uniform (random white noise). Any bias lets attackers in. |
| **Nonce** | "Number used once." A unique input added to the Key to ensure the Keystream is unique every time. |
